# Validation System Specification

## Comprehensive Schema Validation for JobRunner Workflow System

---

## üéØ Overview

This document specifies the comprehensive validation system for the enhanced node schema architecture. The validation system ensures data integrity, schema compliance, and workflow consistency across all node types and connections.

---

## üèóÔ∏è Validation Architecture

### Core Validation Components

```typescript
// Main Validation System Interface
interface ValidationSystem {
  // Schema Validation
  validateSchema(nodeData: NodeData): SchemaValidationResult;
  validateNodeType(
    nodeData: NodeData,
    expectedType: NodeType
  ): TypeValidationResult;

  // Data Integrity Validation
  validateDataIntegrity(
    data: any,
    rules: IntegrityRules
  ): IntegrityValidationResult;
  validateDataFlow(sourceData: any, targetData: any): FlowValidationResult;

  // Connection Validation
  validateConnection(connection: ConnectionData): ConnectionValidationResult;
  validateConnectionCollection(
    connections: ConnectionCollection
  ): CollectionValidationResult;

  // Plugin Validation
  validatePlugin(
    plugin: NodePlugin,
    config: PluginConfiguration
  ): PluginValidationResult;
  validatePluginDependencies(plugin: NodePlugin): DependencyValidationResult;

  // Workflow Validation
  validateWorkflow(
    nodes: Map<string, NodeData>,
    connections: Map<string, ConnectionData>
  ): WorkflowValidationResult;
  validateWorkflowExecution(
    workflow: WorkflowDefinition
  ): ExecutionValidationResult;

  // Cross-validation
  validateCrossReferences(
    nodeData: NodeData,
    relatedNodes: NodeData[]
  ): CrossValidationResult;
  validateDirectives(
    directives: DataDirectiveCollection,
    targetNodes: NodeData[]
  ): DirectiveValidationResult;
}
```

---

## üìã Schema Validation Rules

### Base NodeData Validation

```typescript
interface SchemaValidationRules {
  meta: {
    required: [
      "label",
      "function",
      "emoji",
      "version",
      "category",
      "capabilities"
    ];
    types: {
      label: "string";
      description: "string?";
      function: "string";
      emoji: "string";
      version: "semver";
      category: "enum:input|process|output";
      capabilities: "array<string>";
      tags: "array<string>?";
      author: "string?";
      createdAt: "iso-date";
      updatedAt: "iso-date";
    };
    constraints: {
      label: { minLength: 1; maxLength: 100 };
      emoji: { minLength: 1; maxLength: 10 };
      capabilities: { minItems: 1; uniqueItems: true };
    };
  };

  input: {
    required: ["connections", "processed", "config"];
    types: {
      connections: "ConnectionCollection";
      processed: "ProcessedDataCollection";
      config: "NodeConfiguration";
      formFields: "array<FormFieldDefinition>?";
      validation: "ValidationConfiguration?";
    };
  };

  output: {
    required: ["data", "meta"];
    types: {
      data: "object";
      meta: "OutputMetadata";
      directives: "DataDirectiveCollection?";
      cache: "CacheConfiguration?";
    };
  };

  error: {
    required: ["hasError", "errors", "warnings"];
    types: {
      hasError: "boolean";
      errors: "array<NodeError>";
      warnings: "array<NodeWarning>";
      recoveryActions: "array<RecoveryAction>?";
    };
  };

  styling: {
    required: ["states", "handles"];
    types: {
      states: "object";
      handles: "object";
      custom: "object?";
      theme: "string?";
    };
    constraints: {
      states: {
        requiredStates: [
          "default",
          "selected",
          "processing",
          "success",
          "error"
        ];
      };
    };
  };
}
```

### Node Type Specific Validation

```typescript
interface InputNodeValidationRules extends SchemaValidationRules {
  meta: {
    constraints: {
      category: { equals: "input" };
      capabilities: {
        mustInclude: ["form-collection", "user-input"];
        validCapabilities: [
          "form-collection",
          "user-input",
          "data-generation",
          "validation",
          "directive-generation",
          "file-upload"
        ];
      };
    };
  };

  input: {
    required: ["formFields", "validation", "config"];
    types: {
      formFields: "array<FormFieldDefinition>";
      validation: "ValidationConfiguration";
    };
    constraints: {
      formFields: { minItems: 1; maxItems: 50 };
    };
  };

  output: {
    required: ["data.formData", "data.isValid", "data.validationErrors"];
    constraints: {
      directives: {
        autoGenerated: true;
        maxDirectivesPerTarget: 10;
      };
    };
  };

  styling: {
    constraints: {
      states: {
        requiredStates: ["default", "filled", "invalid", "submitting"];
      };
      handles: {
        output: { required: true; minHandles: 1 };
      };
    };
  };
}

interface ProcessNodeValidationRules extends SchemaValidationRules {
  meta: {
    constraints: {
      category: { equals: "process" };
      capabilities: {
        mustInclude: ["data-processing"];
        validCapabilities: [
          "data-processing",
          "transformation",
          "computation",
          "integration",
          "llm-processing",
          "multi-input"
        ];
      };
    };
  };

  plugin: {
    required: true;
    types: {
      name: "string";
      version: "semver";
      config: "PluginConfiguration";
      state: "PluginState";
      lifecycle: "PluginLifecycle";
      dependencies: "array<PluginDependency>";
      permissions: "PluginPermissions";
    };
  };

  input: {
    constraints: {
      connections: {
        maxConnections: 20;
        requiresAtLeastOne: false; // Can process without inputs
      };
    };
  };

  styling: {
    constraints: {
      states: {
        requiredStates: ["default", "processing", "configured", "error"];
      };
      handles: {
        input: { required: true; minHandles: 1 };
        output: { required: true; minHandles: 1 };
      };
    };
  };
}

interface OutputNodeValidationRules extends SchemaValidationRules {
  meta: {
    constraints: {
      category: { equals: "output" };
      capabilities: {
        mustInclude: ["data-display"];
        validCapabilities: [
          "data-display",
          "file-export",
          "visualization",
          "markdown-rendering",
          "json-display",
          "chart-generation"
        ];
      };
    };
  };

  output: {
    constraints: {
      directives: {
        mustBeEmpty: true; // Output nodes don't generate directives
      };
      data: {
        contentReplication: true; // Must faithfully replicate input
      };
    };
  };

  styling: {
    constraints: {
      states: {
        requiredStates: ["default", "populated", "rendering", "exported"];
      };
      handles: {
        input: { required: true; minHandles: 1 };
        output: { forbidden: true }; // Output nodes are endpoints
      };
    };
  };
}
```

---

## üîó Connection Validation Rules

### Connection Data Validation

```typescript
interface ConnectionValidationRules {
  structure: {
    required: [
      "id",
      "edgeId",
      "sourceNodeId",
      "targetHandle",
      "data",
      "meta",
      "qos"
    ];
    types: {
      id: "string";
      edgeId: "string";
      sourceNodeId: "string";
      sourceHandle: "string";
      targetHandle: "string";
      sourceLabel: "string";
      sourceType: "enum:input|process|output";
      data: "any";
      processed: "any";
      directive: "DataDirective?";
      meta: "ConnectionMetadata";
      qos: "QoSConfiguration";
    };
  };

  constraints: {
    id: {
      pattern: "^[a-zA-Z0-9-_]+-[a-zA-Z0-9-_]+-[a-zA-Z0-9-_]+-[a-zA-Z0-9-_]+$";
      maxLength: 200;
    };
    sourceNodeId: {
      mustExistInWorkflow: true;
      notEqualTo: "targetNodeId"; // Prevent self-connections
    };
    meta: {
      required: ["timestamp", "dataType", "isActive", "priority"];
      constraints: {
        priority: { min: 0; max: 10 };
        bandwidth: { min: 0 };
      };
    };
    qos: {
      required: ["reliability", "durability", "ordering"];
      constraints: {
        reliability: "enum:at-most-once|at-least-once|exactly-once";
      };
    };
  };

  businessRules: {
    // Output nodes cannot be sources
    sourceTypeRestrictions: {
      output: { canBeSource: false };
    };

    // Input nodes cannot be targets (unless allowing external data)
    targetTypeRestrictions: {
      input: {
        canBeTarget: "conditional"; // Based on allowExternalData config
        condition: "node.input.config.allowExternalData === true";
      };
    };

    // Data type compatibility
    dataTypeCompatibility: {
      checkSourceTarget: true;
      allowImplicitConversion: [
        "string->number",
        "number->string",
        "object->string"
      ];
    };
  };
}
```

### Multi-Connection Validation

```typescript
interface MultiConnectionValidationRules {
  targetNodeRules: {
    // Check if target node allows multiple connections
    allowMultipleConnections: {
      checkNodeConfig: true;
      configPath: "input.config.allowMultipleConnections";
      defaultValue: false;
    };

    // Validate connection limits
    connectionLimits: {
      checkMaxConnections: true;
      configPath: "styling.handles.input[].behavior.connectionLimit";
      absoluteMax: 50; // System-wide limit
    };

    // Validate connection types
    connectionTypes: {
      checkAcceptedTypes: true;
      configPath: "styling.handles.input[].behavior.acceptedDataTypes";
      enforceStrict: true;
    };
  };

  aggregationValidation: {
    // Validate aggregation strategy
    strategy: {
      checkValid: true;
      validStrategies: ["merge", "array", "latest", "priority", "custom"];
      configPath: "input.processed.strategy";
    };

    // Validate priority assignments
    priority: {
      checkUniquePriorities: true;
      allowDuplicates: false;
      priorityRange: { min: 0; max: 10 };
    };
  };
}
```

---

## üì§ Directive Validation Rules

### Data Directive Validation

```typescript
interface DirectiveValidationRules {
  structure: {
    required: ["type", "target", "payload", "processing", "meta"];
    types: {
      type: "enum:update-config|modify-behavior|transform-data|custom";
      target: "DirectiveTarget";
      payload: "any";
      processing: "ProcessingInstructions";
      meta: "DirectiveMetadata";
    };
  };

  target: {
    required: ["section", "path", "operation"];
    types: {
      section: "enum:input|output|plugin|styling";
      path: "string";
      operation: "enum:set|merge|append|transform";
    };
    constraints: {
      path: {
        pattern: "^[a-zA-Z][a-zA-Z0-9._\\[\\]]*$"; // Valid dot notation
        maxDepth: 10;
      };
    };
  };

  processing: {
    required: ["immediate", "priority"];
    types: {
      immediate: "boolean";
      conditional: "string?";
      priority: "number";
      retryPolicy: "RetryPolicy?";
    };
    constraints: {
      priority: { min: 0; max: 10 };
      conditional: {
        validExpressions: true; // Must be valid JavaScript expression
        maxLength: 500;
      };
    };
  };

  businessRules: {
    // Validate target node exists and section is valid
    targetValidation: {
      nodeExists: true;
      sectionExists: true;
      pathExists: true;
    };

    // Validate payload matches target type
    payloadCompatibility: {
      checkTypeMatch: true;
      allowConversion: true;
    };

    // Security validation
    security: {
      noCodeInjection: true;
      sanitizePayload: true;
      allowedOperations: ["set", "merge", "append"]; // 'transform' requires special permissions
    };
  };
}
```

---

## üîß Plugin Validation Rules

### Plugin Structure Validation

```typescript
interface PluginValidationRules {
  identity: {
    required: ["name", "version", "description", "author", "license"];
    types: {
      name: "string";
      version: "semver";
      description: "string";
      author: "string";
      license: "string";
    };
    constraints: {
      name: {
        pattern: "^[a-zA-Z][a-zA-Z0-9-_]*$";
        minLength: 3;
        maxLength: 50;
      };
      description: { maxLength: 500 };
    };
  };

  lifecycle: {
    required: ["initialize", "process", "cleanup"];
    types: {
      initialize: "function";
      process: "function";
      cleanup: "function";
      onConnectionAdded: "function?";
      onConnectionRemoved: "function?";
      onConfigurationChanged: "function?";
    };
  };

  capabilities: {
    required: ["getCapabilities", "getConfigSchema", "getDependencies"];
    types: {
      getCapabilities: "function";
      getConfigSchema: "function";
      getDependencies: "function";
      getResourceRequirements: "function?";
      validateEnvironment: "function?";
    };
  };

  multiConnection: {
    optional: [
      "supportsMultipleInputs",
      "getInputAggregationStrategies",
      "processConnectionIndividually"
    ];
    types: {
      supportsMultipleInputs: "function";
      getInputAggregationStrategies: "function";
      processConnectionIndividually: "boolean?";
    };
  };
}
```

### Plugin Configuration Validation

```typescript
interface PluginConfigurationValidationRules {
  structure: {
    validateAgainstSchema: true;
    schemaSource: "plugin.getConfigSchema()";
    requiresValidJSON: true;
  };

  dependencies: {
    validateDependencies: true;
    checkVersionCompatibility: true;
    allowMissingOptionalDeps: true;
  };

  resources: {
    validateResourceRequirements: true;
    checkSystemCapabilities: true;
    enforceResourceLimits: true;
    limits: {
      maxMemory: "1GB";
      maxCPU: "50%";
      maxDiskSpace: "100MB";
      maxNetworkRequests: 1000;
    };
  };

  security: {
    validatePermissions: true;
    sandboxExecution: true;
    allowedModules: ["fs", "path", "crypto", "http", "https"];
    deniedModules: ["child_process", "vm", "eval"];
    maxExecutionTime: 30000; // 30 seconds
  };
}
```

---

## üåä Workflow Validation Rules

### Workflow Structure Validation

```typescript
interface WorkflowValidationRules {
  structure: {
    validateNodeCount: true;
    limits: {
      minNodes: 1;
      maxNodes: 1000;
      maxConnections: 5000;
    };
  };

  connectivity: {
    validateConnectivity: true;
    rules: {
      noOrphanNodes: false; // Allow disconnected nodes
      noCircularDependencies: true;
      maxDepth: 50; // Maximum workflow depth
      validateDataFlow: true;
    };
  };

  consistency: {
    validateNodeIds: true;
    validateConnectionIds: true;
    validateDataTypes: true;
    validateDirectiveTargets: true;
  };

  performance: {
    estimateComplexity: true;
    limits: {
      maxExecutionTime: 300000; // 5 minutes
      maxMemoryUsage: "2GB";
      maxConcurrentNodes: 20;
    };
  };
}
```

### Execution Validation

```typescript
interface ExecutionValidationRules {
  prerequisites: {
    validateAllNodesReady: true;
    validatePluginsInitialized: true;
    validateResourcesAvailable: true;
  };

  runtime: {
    validateDataFlow: true;
    validateDirectiveExecution: true;
    validatePluginExecution: true;
    validateErrorRecovery: true;
  };

  safety: {
    preventInfiniteLoops: true;
    limitExecutionTime: true;
    limitResourceConsumption: true;
    validateSecurity: true;
  };
}
```

---

## üö® Validation Result Structures

### Comprehensive Validation Result

```typescript
interface ValidationResult {
  // Overall status
  isValid: boolean;
  severity: "info" | "warning" | "error" | "critical";

  // Detailed results
  schema: SchemaValidationResult;
  data: DataValidationResult;
  connections: ConnectionValidationResult[];
  plugins: PluginValidationResult[];
  directives: DirectiveValidationResult[];
  workflow: WorkflowValidationResult;

  // Error details
  errors: ValidationError[];
  warnings: ValidationWarning[];
  suggestions: ValidationSuggestion[];

  // Performance metrics
  metrics: {
    validationTime: number;
    checksPerformed: number;
    rulesEvaluated: number;
  };

  // Remediation
  remediation: {
    autoFixable: boolean;
    suggestedFixes: ValidationFix[];
    manualSteps: string[];
  };
}

interface ValidationError {
  code: string;
  message: string;
  path: string; // JSON path to the problematic field
  severity: "error" | "critical";
  context: {
    nodeId?: string;
    connectionId?: string;
    pluginName?: string;
    directiveId?: string;
  };
  remediation: {
    description: string;
    autoFixable: boolean;
    fixAction?: () => void;
  };
}

interface ValidationFix {
  description: string;
  type: "auto" | "manual" | "guided";
  apply: () => Promise<ValidationResult>;
  rollback: () => Promise<void>;
}
```

---

## üéØ Validation Implementation Strategy

### Phase 1: Core Validation (Week 1)

- Implement schema validation for all node types
- Basic connection validation
- Data type checking

### Phase 2: Advanced Features (Week 2)

- Multi-connection validation
- Directive validation
- Plugin validation framework

### Phase 3: Workflow Validation (Week 3)

- Cross-node validation
- Workflow integrity checks
- Performance estimation

### Phase 4: Real-time Validation (Week 4)

- Incremental validation
- Live error reporting
- Auto-fix suggestions

---

## üìà Performance Considerations

### Optimization Strategies

- **Incremental Validation**: Only validate changed parts
- **Caching**: Cache validation results for unchanged data
- **Lazy Evaluation**: Validate on-demand for expensive checks
- **Parallel Validation**: Run independent validations concurrently
- **Early Termination**: Stop on first critical error

### Validation Levels

- **Fast**: Basic schema and type checking (< 1ms)
- **Standard**: Full validation including business rules (< 10ms)
- **Comprehensive**: Deep validation with cross-references (< 100ms)
- **Thorough**: Complete validation with performance analysis (< 1s)

This comprehensive validation system ensures data integrity, schema compliance, and workflow consistency while maintaining excellent performance through smart optimization strategies.
