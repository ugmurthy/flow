/**
 * Integration Tests for DirectiveProcessor with NodeDataManager
 * Tests the complete directive processing workflow in a realistic environment
 */

import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { DirectiveProcessor } from '../services/directiveProcessor.js';
import { NodeDataManager } from '../services/nodeDataManager.js';
import { DataDirective, InputNodeData, ProcessNodeData, OutputNodeData } from '../types/nodeSchema.js';

describe('DirectiveProcessor Integration with NodeDataManager', () => {
  let nodeDataManager;
  let directiveProcessor;

  beforeEach(async () => {
    nodeDataManager = new NodeDataManager();
    await nodeDataManager.initialize();
    directiveProcessor = nodeDataManager.directiveProcessor;
  });

  afterEach(async () => {
    if (nodeDataManager) {
      await nodeDataManager.cleanup();
    }
  });

  describe('End-to-End Directive Processing', () => {
    test('should process directives generated by source node and apply to target nodes', async () => {
      // Setup source and target nodes
      const sourceNode = InputNodeData.create({
        meta: { label: 'Form Input', category: 'input' },
        output: {
          data: { username: 'testuser', email: 'test@example.com' },
          directives: {
            'process-node': [
              DataDirective.create({
                type: 'update-config',
                target: { section: 'input', path: 'config.userInfo' },
                payload: { username: 'testuser', email: 'test@example.com' },
                processing: { immediate: true, priority: 5 }
              })
            ],
            'display-node': [
              DataDirective.create({
                type: 'transform-data',
                target: { section: 'input', path: 'processed.displayData' },
                payload: { formattedUser: 'User: testuser (test@example.com)' },
                processing: { immediate: false, priority: 3 }
              })
            ]
          }
        }
      });

      const processNode = ProcessNodeData.create({
        meta: { label: 'Process Data', category: 'process' },
        input: { config: { userInfo: null } }
      });

      const displayNode = OutputNodeData.create({
        meta: { label: 'Display Output', category: 'output' },
        input: { processed: { displayData: null } }
      });

      // Register nodes with manager
      const mockUpdateCallback = vi.fn();
      nodeDataManager.registerNode('source-node', sourceNode, mockUpdateCallback);
      nodeDataManager.registerNode('process-node', processNode, mockUpdateCallback);
      nodeDataManager.registerNode('display-node', displayNode, mockUpdateCallback);

      // Process the directives from source node
      const results = await directiveProcessor.processDirectives('source-node', sourceNode.output.directives);

      // Verify processing results
      expect(results.totalDirectives).toBe(2);
      expect(results.successful).toBe(1); // Only immediate directive succeeds immediately
      expect(results.results['process-node']).toHaveLength(1);
      expect(results.results['display-node']).toHaveLength(1);

      // Check immediate directive was applied
      const updatedProcessNode = nodeDataManager.getNodeData('process-node');
      expect(updatedProcessNode.input.config.userInfo).toEqual({
        username: 'testuser',
        email: 'test@example.com'
      });

      // Flush batches to process non-immediate directive
      await directiveProcessor.flushBatches();

      // Check batch directive was applied
      const updatedDisplayNode = nodeDataManager.getNodeData('display-node');
      expect(updatedDisplayNode.input.processed.displayData).toEqual({
        formattedUser: 'User: testuser (test@example.com)'
      });
    });

    test('should handle conditional directive execution based on node state', async () => {
      // Create target node with error state
      const targetNode = ProcessNodeData.create({
        meta: { label: 'Target Node' },
        error: { hasError: true, errors: [{ code: 'TEST_ERROR', message: 'Test error' }] },
        input: { connections: {} }
      });

      nodeDataManager.registerNode('target-node', targetNode, vi.fn());

      // Create directive that should only execute when node has no errors
      const directive = DataDirective.create({
        type: 'update-config',
        target: { section: 'input', path: 'config.processWhenReady' },
        payload: true,
        processing: {
          conditional: 'hasErrors === false',
          immediate: true
        }
      });

      // Process directive - should be skipped due to error condition
      let result = await directiveProcessor.processDirective(directive, 'target-node');
      expect(result.success).toBe(true);
      expect(result.skipped).toBe(true);

      // Clear errors and try again
      await nodeDataManager.updateNodeData('target-node', {
        error: { hasError: false, errors: [] }
      });

      result = await directiveProcessor.processDirective(directive, 'target-node');
      expect(result.success).toBe(true);
      expect(result.skipped).toBeUndefined();

      // Verify directive was applied
      const updatedNode = nodeDataManager.getNodeData('target-node');
      expect(updatedNode.input.config.processWhenReady).toBe(true);
    });

    test('should handle retry logic with actual node updates', async () => {
      const targetNode = ProcessNodeData.create({
        meta: { label: 'Flaky Target' }
      });

      nodeDataManager.registerNode('flaky-target', targetNode, vi.fn());

      // Mock _processImmediate to fail twice, then succeed
      let attemptCount = 0;
      const originalProcessImmediate = directiveProcessor._processImmediate;
      directiveProcessor._processImmediate = vi.fn().mockImplementation(async (directive, targetNodeId) => {
        attemptCount++;
        if (attemptCount <= 2) {
          throw new Error(`Attempt ${attemptCount} failed`);
        }
        return originalProcessImmediate.call(directiveProcessor, directive, targetNodeId);
      });

      const directive = DataDirective.create({
        type: 'update-config',
        target: { section: 'input', path: 'config.retriedValue' },
        payload: 'success after retries',
        processing: {
          immediate: true,
          retryPolicy: {
            maxRetries: 3,
            delay: 50,
            backoffMultiplier: 1.5
          }
        }
      });

      const result = await directiveProcessor.processDirective(directive, 'flaky-target');

      // Should fail initially but schedule retry
      expect(result.success).toBe(false);
      expect(result.retryScheduled).toBe(true);

      // Wait for retries to complete
      await new Promise(resolve => setTimeout(resolve, 200));

      // Check that the final retry succeeded
      const updatedNode = nodeDataManager.getNodeData('flaky-target');
      expect(updatedNode.input.config.retriedValue).toBe('success after retries');
    });

    test('should process batch directives with priority ordering', async () => {
      const targetNode = ProcessNodeData.create({
        meta: { label: 'Batch Target' },
        input: { config: { operations: [] } }
      });

      nodeDataManager.registerNode('batch-target', targetNode, vi.fn());

      // Create multiple directives with different priorities
      const directives = [
        DataDirective.create({
          type: 'update-config',
          target: { section: 'input', path: 'config.operations[0]' },
          payload: 'low priority operation',
          processing: { immediate: false, priority: 8 }
        }),
        DataDirective.create({
          type: 'update-config',
          target: { section: 'input', path: 'config.operations[1]' },
          payload: 'high priority operation',
          processing: { immediate: false, priority: 2 }
        }),
        DataDirective.create({
          type: 'update-config',
          target: { section: 'input', path: 'config.operations[2]' },
          payload: 'medium priority operation',
          processing: { immediate: false, priority: 5 }
        })
      ];

      // Process all directives (they should be batched)
      const results = await Promise.all(
        directives.map(directive => 
          directiveProcessor.processDirective(directive, 'batch-target')
        )
      );

      // All should be queued for batch processing
      results.forEach(result => {
        expect(result.success).toBe(true);
        expect(result.result.queued).toBe(true);
      });

      // Verify batch statistics
      const batchStats = directiveProcessor.batchProcessor.getBatchStats();
      expect(batchStats.totalPendingDirectives).toBe(3);

      // Force process batch
      await directiveProcessor.flushBatches();

      // Check that directives were processed in priority order
      // (This is more of a structural test since we can't easily verify order of application)
      const batchStatsAfter = directiveProcessor.batchProcessor.getBatchStats();
      expect(batchStatsAfter.totalPendingDirectives).toBe(0);
    });

    test('should handle complex nested path operations', async () => {
      const targetNode = ProcessNodeData.create({
        meta: { label: 'Complex Target' },
        input: {
          config: {
            nested: {
              deep: {
                array: [{ value: 1 }, { value: 2 }],
                object: { prop: 'initial' }
              }
            }
          }
        }
      });

      nodeDataManager.registerNode('complex-target', targetNode, vi.fn());

      // Test different operation types
      const directives = [
        // Set operation
        DataDirective.create({
          type: 'update-config',
          target: { 
            section: 'input', 
            path: 'config.nested.deep.object.prop',
            operation: 'set'
          },
          payload: 'updated value'
        }),
        // Merge operation
        DataDirective.create({
          type: 'update-config',
          target: { 
            section: 'input', 
            path: 'config.nested.deep.object',
            operation: 'merge'
          },
          payload: { newProp: 'merged value' }
        }),
        // Append operation
        DataDirective.create({
          type: 'update-config',
          target: { 
            section: 'input', 
            path: 'config.nested.deep.array',
            operation: 'append'
          },
          payload: { value: 3 }
        })
      ];

      // Process all directives
      for (const directive of directives) {
        const result = await directiveProcessor.processDirective(directive, 'complex-target');
        expect(result.success).toBe(true);
      }

      // Verify all operations were applied correctly
      const updatedNode = nodeDataManager.getNodeData('complex-target');
      const deepConfig = updatedNode.input.config.nested.deep;

      expect(deepConfig.object.prop).toBe('updated value');
      expect(deepConfig.object.newProp).toBe('merged value');
      expect(deepConfig.array).toHaveLength(3);
      expect(deepConfig.array[2]).toEqual({ value: 3 });
    });

    test('should handle directive processing during node execution workflow', async () => {
      // Create a realistic workflow: Input -> Process -> Output
      const inputNode = InputNodeData.create({
        meta: { label: 'User Form' },
        output: {
          data: { name: 'John Doe', age: 30 },
          directives: {
            'processor': [
              DataDirective.create({
                type: 'update-config',
                target: { section: 'input', path: 'config.userData' },
                payload: { name: 'John Doe', age: 30 },
                processing: { immediate: true }
              })
            ]
          }
        }
      });

      const processNode = ProcessNodeData.create({
        meta: { label: 'Data Processor' },
        input: { config: { userData: null } },
        output: {
          data: {},
          directives: {
            'output-display': [
              DataDirective.create({
                type: 'update-config',
                target: { section: 'input', path: 'config.displayContent' },
                payload: 'Processed: John Doe (30 years old)',
                processing: { 
                  conditional: 'input && input.config && input.config.userData',
                  immediate: true
                }
              })
            ]
          }
        }
      });

      const outputNode = OutputNodeData.create({
        meta: { label: 'Display' },
        input: { config: { displayContent: null } }
      });

      // Register nodes
      const mockCallback = vi.fn();
      nodeDataManager.registerNode('input', inputNode, mockCallback);
      nodeDataManager.registerNode('processor', processNode, mockCallback);
      nodeDataManager.registerNode('output-display', outputNode, mockCallback);

      // Simulate workflow execution
      // 1. Process input node directives
      await directiveProcessor.processDirectives('input', inputNode.output.directives);

      // Verify processor received data
      const updatedProcessor = nodeDataManager.getNodeData('processor');
      expect(updatedProcessor.input.config.userData).toEqual({ name: 'John Doe', age: 30 });

      // 2. Update processor output and process its directives
      await nodeDataManager.updateNodeData('processor', {
        output: {
          data: { processedUser: 'John Doe (30 years old)' }
        }
      });

      const updatedProcessorWithOutput = nodeDataManager.getNodeData('processor');
      await directiveProcessor.processDirectives('processor', updatedProcessorWithOutput.output.directives);

      // 3. Verify output node received processed data
      const updatedOutput = nodeDataManager.getNodeData('output-display');
      expect(updatedOutput.input.config.displayContent).toBe('Processed: John Doe (30 years old)');
    });
  });

  describe('Error Scenarios and Recovery', () => {
    test('should handle directive processing errors without affecting node manager', async () => {
      const targetNode = ProcessNodeData.create({
        meta: { label: 'Target Node' }
      });

      nodeDataManager.registerNode('target', targetNode, vi.fn());

      // Create invalid directive that will fail
      const invalidDirective = {
        type: 'invalid-type',
        target: { section: 'nonexistent', path: 'invalid.path' },
        payload: 'test'
        // Missing processing and meta
      };

      const result = await directiveProcessor.processDirective(invalidDirective, 'target');

      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid directive');

      // Node manager should still be functional
      await nodeDataManager.updateNodeData('target', {
        output: { data: { test: 'still works' } }
      });

      const updatedNode = nodeDataManager.getNodeData('target');
      expect(updatedNode.output.data.test).toBe('still works');
    });

    test('should handle missing target node gracefully', async () => {
      const directive = DataDirective.create({
        type: 'update-config',
        target: { section: 'input', path: 'config.test' },
        payload: 'test'
      });

      const result = await directiveProcessor.processDirective(directive, 'nonexistent-node');

      expect(result.success).toBe(false);
      expect(result.error).toContain('Target node nonexistent-node not found');
    });

    test('should clean up properly after processing errors', async () => {
      const initialStats = directiveProcessor.getStats();
      
      // Process some successful and failed directives
      const targetNode = ProcessNodeData.create({ meta: { label: 'Test' } });
      nodeDataManager.registerNode('test', targetNode, vi.fn());

      const validDirective = DataDirective.create({
        type: 'update-config',
        target: { section: 'input', path: 'config.valid' },
        payload: 'valid'
      });

      const invalidDirective = {
        type: 'invalid'
        // Missing required fields
      };

      await directiveProcessor.processDirective(validDirective, 'test');
      await directiveProcessor.processDirective(invalidDirective, 'test');

      const statsBeforeCleanup = directiveProcessor.getStats();
      expect(statsBeforeCleanup.totalProcessed).toBeGreaterThan(initialStats.totalProcessed);

      // Cleanup should reset stats
      await directiveProcessor.cleanup();

      const statsAfterCleanup = directiveProcessor.getStats();
      expect(statsAfterCleanup.totalProcessed).toBe(0);
      expect(statsAfterCleanup.successful).toBe(0);
      expect(statsAfterCleanup.failed).toBe(0);
    });
  });

  describe('Performance and Scalability', () => {
    test('should handle large number of directives efficiently', async () => {
      const targetNodes = [];
      const nodeCount = 50;
      const directivesPerNode = 10;

      // Create many target nodes
      for (let i = 0; i < nodeCount; i++) {
        const node = ProcessNodeData.create({
          meta: { label: `Target ${i}` }
        });
        nodeDataManager.registerNode(`target-${i}`, node, vi.fn());
        targetNodes.push(`target-${i}`);
      }

      // Create directives map
      const directivesMap = {};
      targetNodes.forEach(nodeId => {
        directivesMap[nodeId] = [];
        for (let j = 0; j < directivesPerNode; j++) {
          directivesMap[nodeId].push(
            DataDirective.create({
              type: 'update-config',
              target: { section: 'input', path: `config.value${j}` },
              payload: `value-${j}`,
              processing: { immediate: j % 2 === 0 } // Mix immediate and batch
            })
          );
        }
      });

      // Measure processing time
      const startTime = Date.now();
      const results = await directiveProcessor.processDirectives('source', directivesMap);
      const processingTime = Date.now() - startTime;

      // Flush batches
      await directiveProcessor.flushBatches();
      const totalTime = Date.now() - startTime;

      // Verify all directives were processed
      expect(results.totalDirectives).toBe(nodeCount * directivesPerNode);
      expect(results.successful + results.failed).toBe(results.totalDirectives);

      // Performance assertions (should handle 500 directives in reasonable time)
      expect(totalTime).toBeLessThan(5000); // Less than 5 seconds
      expect(processingTime / results.totalDirectives).toBeLessThan(10); // Less than 10ms per directive

      console.log(`Processed ${results.totalDirectives} directives in ${totalTime}ms`);
    });
  });
});