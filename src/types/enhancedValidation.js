/**
 * Enhanced Validation System - Phase 3 Implementation
 * Comprehensive validation framework for JobRunner Workflow System
 * 
 * Based on VALIDATION_SYSTEM_SPECIFICATION.md and COMPREHENSIVE_IMPLEMENTATION_PLAN.md
 */

import { z } from 'zod';
import { validateNodeData, validateMeta, validateInput, validateOutput, validateError, validatePlugin } from './nodeDataValidation.js';
import { ValidationResult } from './pluginSystem.js';

// ===========================
// SCHEMA VALIDATION RULES
// ===========================

/**
 * Enhanced schema validation rules based on comprehensive specification
 */
export const SchemaValidationRules = {
  meta: {
    required: [
      "label",
      "function", 
      "emoji",
      "version",
      "category",
      "capabilities"
    ],
    types: {
      label: "string",
      description: "string?",
      function: "string",
      emoji: "string", 
      version: "semver",
      category: "enum:input|process|output",
      capabilities: "array<string>",
      tags: "array<string>?",
      author: "string?",
      createdAt: "iso-date",
      updatedAt: "iso-date"
    },
    constraints: {
      label: { minLength: 1, maxLength: 100 },
      emoji: { minLength: 1, maxLength: 10 },
      capabilities: { minItems: 1, uniqueItems: true }
    }
  },
  
  input: {
    required: ["connections", "processed", "config"],
    types: {
      connections: "ConnectionCollection",
      processed: "ProcessedDataCollection", 
      config: "NodeConfiguration",
      formFields: "array<FormFieldDefinition>?",
      validation: "ValidationConfiguration?"
    }
  },

  output: {
    required: ["data", "meta"],
    types: {
      data: "object",
      meta: "OutputMetadata",
      directives: "DataDirectiveCollection?",
      cache: "CacheConfiguration?"
    }
  },

  error: {
    required: ["hasError", "errors", "warnings"],
    types: {
      hasError: "boolean",
      errors: "array<NodeError>", 
      warnings: "array<NodeWarning>",
      recoveryActions: "array<RecoveryAction>?"
    }
  },

  styling: {
    required: ["states", "handles"],
    types: {
      states: "object",
      handles: "object",
      custom: "object?",
      theme: "string?"
    },
    constraints: {
      states: {
        requiredStates: [
          "default",
          "selected", 
          "processing",
          "success",
          "error"
        ]
      }
    }
  }
};

/**
 * Node type specific validation rules
 */
export const NodeTypeValidationRules = {
  input: {
    meta: {
      constraints: {
        category: { equals: "input" },
        capabilities: {
          mustInclude: ["form-collection", "user-input"],
          validCapabilities: [
            "form-collection",
            "user-input", 
            "data-generation",
            "validation",
            "directive-generation",
            "file-upload"
          ]
        }
      }
    },
    input: {
      required: ["formFields", "validation", "config"],
      types: {
        formFields: "array<FormFieldDefinition>",
        validation: "ValidationConfiguration"
      },
      constraints: {
        formFields: { minItems: 1, maxItems: 50 }
      }
    },
    output: {
      required: ["data.formData", "data.isValid", "data.validationErrors"],
      constraints: {
        directives: {
          autoGenerated: true,
          maxDirectivesPerTarget: 10
        }
      }
    },
    styling: {
      constraints: {
        states: {
          requiredStates: ["default", "filled", "invalid", "submitting"]
        },
        handles: {
          output: { required: true, minHandles: 1 }
        }
      }
    }
  },

  process: {
    meta: {
      constraints: {
        category: { equals: "process" },
        capabilities: {
          mustInclude: ["data-processing"],
          validCapabilities: [
            "data-processing",
            "transformation",
            "computation", 
            "integration",
            "llm-processing",
            "multi-input"
          ]
        }
      }
    },
    plugin: {
      required: true,
      types: {
        name: "string",
        version: "semver",
        config: "PluginConfiguration",
        state: "PluginState",
        lifecycle: "PluginLifecycle",
        dependencies: "array<PluginDependency>",
        permissions: "PluginPermissions"
      }
    },
    input: {
      constraints: {
        connections: {
          maxConnections: 20,
          requiresAtLeastOne: false
        }
      }
    },
    styling: {
      constraints: {
        states: {
          requiredStates: ["default", "processing", "configured", "error"]
        },
        handles: {
          input: { required: true, minHandles: 1 },
          output: { required: true, minHandles: 1 }
        }
      }
    }
  },

  output: {
    meta: {
      constraints: {
        category: { equals: "output" },
        capabilities: {
          mustInclude: ["data-display"],
          validCapabilities: [
            "data-display",
            "file-export",
            "visualization",
            "markdown-rendering",
            "json-display",
            "chart-generation"
          ]
        }
      }
    },
    output: {
      constraints: {
        directives: {
          mustBeEmpty: true
        },
        data: {
          contentReplication: true
        }
      }
    },
    styling: {
      constraints: {
        states: {
          requiredStates: ["default", "populated", "rendering", "exported"]
        },
        handles: {
          input: { required: true, minHandles: 1 },
          output: { forbidden: true }
        }
      }
    }
  }
};

// ===========================
// MULTI-CONNECTION VALIDATOR
// ===========================

/**
 * Multi-Connection validation system
 */
export const MultiConnectionValidator = {
  /**
   * Validate connection limits for a node
   * @param {Object} nodeData - Node data to validate
   * @param {Object} newConnection - New connection being added
   * @returns {Object} Validation result
   */
  validateConnectionLimits(nodeData, newConnection) {
    const errors = [];
    const warnings = [];
    
    if (!nodeData || !newConnection) {
      return ValidationResult.error(['NodeData and connection are required for validation']);
    }

    // Get current connection count
    const currentConnections = Object.keys(nodeData.input?.connections || {}).length;
    
    // Check node-specific limits
    const nodeConfig = nodeData.input?.config || {};
    const allowMultiple = nodeConfig.allowMultipleConnections !== false;
    
    if (!allowMultiple && currentConnections >= 1) {
      errors.push({
        code: 'CONNECTION_LIMIT_EXCEEDED',
        message: `Node does not allow multiple connections. Current: ${currentConnections}`,
        path: 'input.connections',
        context: { nodeId: nodeData.id, currentCount: currentConnections }
      });
    }

    // Check styling handle limits
    const handleConfig = nodeData.styling?.handles?.input || [];
    const targetHandle = newConnection.targetHandle || 'default';
    const handleDef = handleConfig.find(h => h.id === targetHandle);
    
    if (handleDef?.behavior?.connectionLimit) {
      const limit = handleDef.behavior.connectionLimit;
      if (currentConnections >= limit) {
        errors.push({
          code: 'HANDLE_CONNECTION_LIMIT_EXCEEDED',
          message: `Handle '${targetHandle}' connection limit exceeded. Limit: ${limit}, Current: ${currentConnections}`,
          path: `styling.handles.input.${targetHandle}`,
          context: { handle: targetHandle, limit, currentCount: currentConnections }
        });
      }
    }

    // System-wide absolute limit
    const ABSOLUTE_MAX = 50;
    if (currentConnections >= ABSOLUTE_MAX) {
      errors.push({
        code: 'ABSOLUTE_CONNECTION_LIMIT_EXCEEDED',
        message: `Absolute system connection limit exceeded. Maximum: ${ABSOLUTE_MAX}`,
        path: 'input.connections',
        context: { absoluteMax: ABSOLUTE_MAX, currentCount: currentConnections }
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      metrics: {
        currentConnections,
        allowsMultiple: allowMultiple,
        absoluteMax: ABSOLUTE_MAX
      }
    };
  },

  /**
   * Validate aggregation strategy
   * @param {string} strategy - Aggregation strategy to validate
   * @param {Object} nodeData - Node data context
   * @returns {Object} Validation result
   */
  validateAggregationStrategy(strategy, nodeData = {}) {
    const errors = [];
    const warnings = [];
    
    const validStrategies = ['merge', 'array', 'latest', 'priority', 'custom'];
    
    if (!strategy) {
      errors.push({
        code: 'MISSING_AGGREGATION_STRATEGY',
        message: 'Aggregation strategy is required for multi-connection processing',
        path: 'input.processed.strategy'
      });
    } else if (!validStrategies.includes(strategy)) {
      errors.push({
        code: 'INVALID_AGGREGATION_STRATEGY',
        message: `Invalid aggregation strategy '${strategy}'. Valid options: ${validStrategies.join(', ')}`,
        path: 'input.processed.strategy',
        context: { provided: strategy, valid: validStrategies }
      });
    }

    // Validate priority strategy requirements
    if (strategy === 'priority') {
      const connections = nodeData.input?.connections || {};
      const connectionIds = Object.keys(connections);
      
      if (connectionIds.length > 1) {
        const priorities = connectionIds.map(id => connections[id]?.meta?.priority);
        const uniquePriorities = new Set(priorities.filter(p => p !== undefined));
        
        if (uniquePriorities.size !== connectionIds.length) {
          warnings.push({
            code: 'DUPLICATE_CONNECTION_PRIORITIES',
            message: 'Priority strategy requires unique priorities for all connections',
            path: 'input.connections',
            context: { priorities: Array.from(uniquePriorities), connectionCount: connectionIds.length }
          });
        }
      }
    }

    // Validate custom strategy implementation
    if (strategy === 'custom') {
      const customHandler = nodeData.plugin?.config?.customAggregationHandler;
      if (!customHandler) {
        errors.push({
          code: 'MISSING_CUSTOM_AGGREGATION_HANDLER',
          message: 'Custom aggregation strategy requires customAggregationHandler in plugin config',
          path: 'plugin.config.customAggregationHandler'
        });
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      validatedStrategy: strategy,
      supportedStrategies: validStrategies
    };
  },

  /**
   * Validate data type compatibility between connections
   * @param {string} sourceType - Source data type
   * @param {string} targetType - Target expected type 
   * @param {Object} options - Validation options
   * @returns {Object} Validation result
   */
  validateDataTypeCompatibility(sourceType, targetType, options = {}) {
    const errors = [];
    const warnings = [];
    const { allowImplicitConversion = true } = options;
    
    if (!sourceType || !targetType) {
      return {
        isValid: true,
        warnings: [{
          code: 'UNKNOWN_DATA_TYPES',
          message: 'Cannot validate compatibility with unknown data types',
          context: { sourceType, targetType }
        }]
      };
    }

    // Direct type match
    if (sourceType === targetType) {
      return { isValid: true, errors: [], warnings: [] };
    }

    // Check if any type accepts all
    if (targetType === 'any' || sourceType === 'any') {
      return { isValid: true, errors: [], warnings: [] };
    }

    // Implicit conversions allowed
    const implicitConversions = [
      'string->number',
      'number->string', 
      'object->string',
      'array->string',
      'boolean->string',
      'string->boolean'
    ];
    
    const conversionKey = `${sourceType}->${targetType}`;
    
    if (allowImplicitConversion && implicitConversions.includes(conversionKey)) {
      warnings.push({
        code: 'IMPLICIT_TYPE_CONVERSION',
        message: `Data will be implicitly converted from ${sourceType} to ${targetType}`,
        context: { sourceType, targetType, conversionType: 'implicit' }
      });
      
      return { isValid: true, errors: [], warnings };
    }

    // Incompatible types
    errors.push({
      code: 'INCOMPATIBLE_DATA_TYPES',
      message: `Incompatible data types: source '${sourceType}' cannot connect to target '${targetType}'`,
      context: { 
        sourceType, 
        targetType,
        allowedConversions: implicitConversions,
        suggestion: 'Add a data transformation node between incompatible types'
      }
    });

    return {
      isValid: false,
      errors,
      warnings,
      compatibility: {
        direct: false,
        implicit: false,
        requiresTransformation: true
      }
    };
  },

  /**
   * Validate complete multi-connection setup
   * @param {Object} nodeData - Node data with multiple connections
   * @returns {Object} Comprehensive validation result
   */
  validateMultiConnectionSetup(nodeData) {
    const errors = [];
    const warnings = [];
    const connectionAnalysis = [];
    
    if (!nodeData?.input?.connections) {
      return {
        isValid: true,
        errors: [],
        warnings: [{
          code: 'NO_CONNECTIONS',
          message: 'Node has no input connections',
          context: { nodeId: nodeData.id }
        }]
      };
    }

    const connections = nodeData.input.connections;
    const connectionIds = Object.keys(connections);
    const connectionCount = connectionIds.length;

    // Validate aggregation strategy if multiple connections
    if (connectionCount > 1) {
      const strategy = nodeData.input.processed?.strategy;
      const strategyValidation = this.validateAggregationStrategy(strategy, nodeData);
      
      if (!strategyValidation.isValid) {
        errors.push(...strategyValidation.errors);
      }
      warnings.push(...strategyValidation.warnings);
    }

    // Validate each connection
    for (const [connectionId, connection] of Object.entries(connections)) {
      const connectionValidation = this.validateConnectionLimits(nodeData, connection);
      connectionAnalysis.push({
        connectionId,
        validation: connectionValidation
      });
      
      if (!connectionValidation.isValid) {
        errors.push(...connectionValidation.errors.map(err => ({
          ...err,
          context: { ...err.context, connectionId }
        })));
      }
    }

    // Performance warnings for high connection counts
    if (connectionCount > 10) {
      warnings.push({
        code: 'HIGH_CONNECTION_COUNT',
        message: `High connection count (${connectionCount}) may impact performance`,
        context: { connectionCount, recommendation: 'Consider using fewer connections with data aggregation' }
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      metrics: {
        connectionCount,
        strategy: nodeData.input.processed?.strategy,
        hasMultipleConnections: connectionCount > 1
      },
      connectionAnalysis
    };
  }
};

// ===========================
// DIRECTIVE VALIDATOR  
// ===========================

/**
 * Data directive validation system
 */
export const DirectiveValidator = {
  /**
   * Validate directive structure
   * @param {Object} directive - Directive to validate
   * @returns {Object} Validation result
   */
  validateDirectiveStructure(directive) {
    const errors = [];
    const warnings = [];
    
    if (!directive) {
      return ValidationResult.error(['Directive is required']);
    }

    // Required fields
    const required = ['type', 'target', 'payload', 'processing', 'meta'];
    for (const field of required) {
      if (!directive[field]) {
        errors.push({
          code: 'MISSING_DIRECTIVE_FIELD',
          message: `Directive field '${field}' is required`,
          path: field
        });
      }
    }

    // Validate type
    const validTypes = ['update-config', 'modify-behavior', 'transform-data', 'custom'];
    if (directive.type && !validTypes.includes(directive.type)) {
      errors.push({
        code: 'INVALID_DIRECTIVE_TYPE',
        message: `Invalid directive type '${directive.type}'. Valid types: ${validTypes.join(', ')}`,
        path: 'type',
        context: { provided: directive.type, valid: validTypes }
      });
    }

    // Validate target structure
    if (directive.target) {
      const targetValidation = this.validateDirectiveTarget(directive.target);
      if (!targetValidation.isValid) {
        errors.push(...targetValidation.errors.map(err => ({
          ...err,
          path: `target.${err.path}`
        })));
      }
    }

    // Validate processing instructions
    if (directive.processing) {
      const processingValidation = this.validateProcessingInstructions(directive.processing);
      if (!processingValidation.isValid) {
        errors.push(...processingValidation.errors.map(err => ({
          ...err,
          path: `processing.${err.path}`
        })));
      }
      warnings.push(...processingValidation.warnings);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      validatedDirective: {
        type: directive.type,
        hasValidTarget: directive.target && !errors.some(e => e.path.startsWith('target')),
        hasValidProcessing: directive.processing && !errors.some(e => e.path.startsWith('processing'))
      }
    };
  },

  /**
   * Validate directive target specification
   * @param {Object} target - Target specification
   * @returns {Object} Validation result
   */
  validateDirectiveTarget(target) {
    const errors = [];
    
    if (!target) {
      return ValidationResult.error(['Target specification is required']);
    }

    // Required fields
    if (!target.section) {
      errors.push({
        code: 'MISSING_TARGET_SECTION',
        message: 'Target section is required',
        path: 'section'
      });
    }

    if (!target.path) {
      errors.push({
        code: 'MISSING_TARGET_PATH',
        message: 'Target path is required',
        path: 'path'
      });
    }

    // Validate section
    const validSections = ['input', 'output', 'plugin', 'styling'];
    if (target.section && !validSections.includes(target.section)) {
      errors.push({
        code: 'INVALID_TARGET_SECTION',
        message: `Invalid target section '${target.section}'. Valid sections: ${validSections.join(', ')}`,
        path: 'section',
        context: { provided: target.section, valid: validSections }
      });
    }

    // Validate path format (dot notation)
    if (target.path) {
      const pathPattern = /^[a-zA-Z][a-zA-Z0-9._\[\]]*$/;
      if (!pathPattern.test(target.path)) {
        errors.push({
          code: 'INVALID_TARGET_PATH_FORMAT',
          message: `Target path '${target.path}' must be valid dot notation`,
          path: 'path',
          context: { 
            provided: target.path,
            pattern: pathPattern.toString(),
            example: 'config.formFields[0].label'
          }
        });
      }

      // Check path depth
      const pathDepth = target.path.split(/[.\[\]]/).length;
      if (pathDepth > 10) {
        errors.push({
          code: 'TARGET_PATH_TOO_DEEP',
          message: `Target path depth (${pathDepth}) exceeds maximum of 10 levels`,
          path: 'path',
          context: { depth: pathDepth, maxDepth: 10 }
        });
      }
    }

    // Validate operation
    const validOperations = ['set', 'merge', 'append', 'transform'];
    const operation = target.operation || 'set';
    if (!validOperations.includes(operation)) {
      errors.push({
        code: 'INVALID_TARGET_OPERATION',
        message: `Invalid target operation '${operation}'. Valid operations: ${validOperations.join(', ')}`,
        path: 'operation',
        context: { provided: operation, valid: validOperations }
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      validatedTarget: {
        section: target.section,
        path: target.path,
        operation,
        depth: target.path ? target.path.split(/[.\[\]]/).length : 0
      }
    };
  },

  /**
   * Validate processing instructions
   * @param {Object} processing - Processing instructions
   * @returns {Object} Validation result
   */
  validateProcessingInstructions(processing) {
    const errors = [];
    const warnings = [];
    
    if (!processing) {
      return ValidationResult.error(['Processing instructions are required']);
    }

    // Validate immediate flag
    if (processing.immediate === undefined) {
      errors.push({
        code: 'MISSING_IMMEDIATE_FLAG',
        message: 'Processing immediate flag is required',
        path: 'immediate'
      });
    }

    // Validate priority
    if (processing.priority === undefined) {
      errors.push({
        code: 'MISSING_PRIORITY',
        message: 'Processing priority is required',
        path: 'priority'
      });
    } else if (typeof processing.priority !== 'number' || processing.priority < 0 || processing.priority > 10) {
      errors.push({
        code: 'INVALID_PRIORITY_RANGE',
        message: 'Priority must be a number between 0 and 10',
        path: 'priority',
        context: { provided: processing.priority, min: 0, max: 10 }
      });
    }

    // Validate conditional expressions
    if (processing.conditional) {
      if (typeof processing.conditional !== 'string') {
        errors.push({
          code: 'INVALID_CONDITIONAL_TYPE',
          message: 'Conditional expression must be a string',
          path: 'conditional'
        });
      } else if (processing.conditional.length > 500) {
        errors.push({
          code: 'CONDITIONAL_TOO_LONG',
          message: 'Conditional expression exceeds maximum length of 500 characters',
          path: 'conditional',
          context: { length: processing.conditional.length, maxLength: 500 }
        });
      } else {
        // Basic validation for JavaScript expression safety
        const dangerousPatterns = [
          /eval\s*\(/,
          /Function\s*\(/,
          /require\s*\(/,
          /import\s*\(/,
          /document\./,
          /window\./,
          /process\./
        ];

        for (const pattern of dangerousPatterns) {
          if (pattern.test(processing.conditional)) {
            errors.push({
              code: 'UNSAFE_CONDITIONAL_EXPRESSION',
              message: 'Conditional expression contains potentially unsafe code',
              path: 'conditional',
              context: { 
                expression: processing.conditional,
                reason: 'Contains restricted function or object access'
              }
            });
            break;
          }
        }
      }
    }

    // Validate retry policy
    if (processing.retryPolicy) {
      const retryValidation = this.validateRetryPolicy(processing.retryPolicy);
      if (!retryValidation.isValid) {
        errors.push(...retryValidation.errors.map(err => ({
          ...err,
          path: `retryPolicy.${err.path}`
        })));
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      processingSummary: {
        immediate: processing.immediate,
        priority: processing.priority,
        hasConditional: !!processing.conditional,
        hasRetryPolicy: !!processing.retryPolicy
      }
    };
  },

  /**
   * Validate retry policy configuration  
   * @param {Object} retryPolicy - Retry policy to validate
   * @returns {Object} Validation result
   */
  validateRetryPolicy(retryPolicy) {
    const errors = [];
    
    if (retryPolicy.maxRetries !== undefined) {
      if (typeof retryPolicy.maxRetries !== 'number' || retryPolicy.maxRetries < 0 || retryPolicy.maxRetries > 10) {
        errors.push({
          code: 'INVALID_MAX_RETRIES',
          message: 'maxRetries must be a number between 0 and 10',
          path: 'maxRetries'
        });
      }
    }

    if (retryPolicy.delay !== undefined) {
      if (typeof retryPolicy.delay !== 'number' || retryPolicy.delay < 0) {
        errors.push({
          code: 'INVALID_RETRY_DELAY',
          message: 'Retry delay must be a non-negative number',
          path: 'delay'
        });
      }
    }

    if (retryPolicy.backoffMultiplier !== undefined) {
      if (typeof retryPolicy.backoffMultiplier !== 'number' || retryPolicy.backoffMultiplier <= 0) {
        errors.push({
          code: 'INVALID_BACKOFF_MULTIPLIER',
          message: 'Backoff multiplier must be a positive number',
          path: 'backoffMultiplier'
        });
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  },

  /**
   * Validate directive target path exists in node
   * @param {Object} directive - Directive with target
   * @param {Object} targetNode - Target node data
   * @returns {Object} Validation result
   */
  validateTargetPath(directive, targetNode) {
    const errors = [];
    const warnings = [];
    
    if (!directive?.target || !targetNode) {
      return ValidationResult.error(['Directive target and target node are required']);
    }

    const { section, path } = directive.target;
    
    // Check if section exists
    if (!targetNode[section]) {
      errors.push({
        code: 'TARGET_SECTION_NOT_FOUND',
        message: `Target section '${section}' does not exist in node`,
        context: { 
          section, 
          availableSections: Object.keys(targetNode),
          nodeId: targetNode.id
        }
      });
      return { isValid: false, errors, warnings };
    }

    // Navigate to target path
    const pathParts = path.split(/[.\[\]]/).filter(Boolean);
    let current = targetNode[section];
    let currentPath = section;
    
    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      currentPath += `.${part}`;
      
      if (current === null || current === undefined) {
        warnings.push({
          code: 'INTERMEDIATE_PATH_NULL',
          message: `Intermediate path '${currentPath}' is null/undefined`,
          context: { path: currentPath, fullPath: path }
        });
        break;
      }
      
      if (typeof current === 'object' && part in current) {
        current = current[part];
      } else if (Array.isArray(current)) {
        const index = parseInt(part);
        if (!isNaN(index) && index < current.length) {
          current = current[index];
        } else {
          warnings.push({
            code: 'ARRAY_INDEX_OUT_OF_BOUNDS',
            message: `Array index '${part}' is out of bounds or invalid`,
            context: { 
              index: part, 
              arrayLength: current.length,
              path: currentPath 
            }
          });
          break;
        }
      } else {
        warnings.push({
          code: 'PATH_PROPERTY_NOT_FOUND',
          message: `Property '${part}' not found at path '${currentPath}'`,
          context: { 
            property: part,
            path: currentPath,
            availableProperties: typeof current === 'object' ? Object.keys(current) : []
          }
        });
        break;
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      pathAnalysis: {
        exists: warnings.length === 0,
        navigableDepth: pathParts.length - 1,
        finalValue: current
      }
    };
  },

  /**
   * Validate payload compatibility with target
   * @param {Object} directive - Directive with payload  
   * @returns {Object} Validation result
   */
  validatePayloadCompatibility(directive) {
    const errors = [];
    const warnings = [];
    
    if (!directive) {
      return ValidationResult.error(['Directive is required']);
    }

    const { target, payload } = directive;
    
    if (!target) {
      return ValidationResult.error(['Directive target is required']);
    }

    // Basic payload validation
    if (payload === undefined) {
      warnings.push({
        code: 'UNDEFINED_PAYLOAD',
        message: 'Directive payload is undefined',
        context: { operation: target.operation }
      });
    }

    // Operation-specific validation
    switch (target.operation) {
      case 'set':
        // Set operation can accept any payload
        break;
        
      case 'merge':
        if (payload !== null && typeof payload !== 'object') {
          errors.push({
            code: 'MERGE_REQUIRES_OBJECT',
            message: 'Merge operation requires object payload',
            context: { 
              payloadType: typeof payload,
              operation: 'merge'
            }
          });
        }
        break;
        
      case 'append':
        if (!Array.isArray(payload) && typeof payload !== 'string') {
          errors.push({
            code: 'APPEND_REQUIRES_ARRAY_OR_STRING',
            message: 'Append operation requires array or string payload',
            context: {
              payloadType: typeof payload,
              operation: 'append'
            }
          });
        }
        break;
        
      case 'transform':
        if (typeof payload !== 'function' && typeof payload !== 'string') {
          errors.push({
            code: 'TRANSFORM_REQUIRES_FUNCTION',
            message: 'Transform operation requires function or string payload',
            context: {
              payloadType: typeof payload,
              operation: 'transform'
            }
          });
        }
        break;
        
      default:
        warnings.push({
          code: 'UNKNOWN_OPERATION',
          message: `Unknown operation '${target.operation}' - payload compatibility cannot be validated`,
          context: { operation: target.operation }
        });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      compatibility: {
        operation: target.operation,
        payloadType: typeof payload,
        isCompatible: errors.length === 0
      }
    };
  }
};

// ===========================
// CROSS-NODE VALIDATION UTILITIES
// ===========================

/**
 * Cross-node validation utilities
 */
export const CrossNodeValidator = {
  /**
   * Validate workflow integrity across all nodes
   * @param {Array} nodes - Array of workflow nodes
   * @param {Array} edges - Array of workflow edges
   * @returns {Object} Validation result
   */
  validateWorkflowIntegrity(nodes, edges) {
    const errors = [];
    const warnings = [];
    const nodeMap = new Map();
    const edgeMap = new Map();
    
    // Build maps for efficient lookup
    nodes.forEach(node => nodeMap.set(node.id, node));
    edges.forEach(edge => edgeMap.set(edge.id, edge));
    
    // Validate each node individually
    const nodeValidations = [];
    for (const node of nodes) {
      const validation = this.validateNodeIntegrity(node, nodes, edges);
      nodeValidations.push({
        nodeId: node.id,
        validation
      });
      
      if (!validation.isValid) {
        errors.push(...validation.errors.map(err => ({
          ...err,
          context: { ...err.context, nodeId: node.id }
        })));
      }
      warnings.push(...validation.warnings);
    }
    
    // Validate workflow structure
    const structureValidation = this.validateWorkflowStructure(nodes, edges);
    if (!structureValidation.isValid) {
      errors.push(...structureValidation.errors);
    }
    warnings.push(...structureValidation.warnings);
    
    // Validate data flow consistency
    const dataFlowValidation = this.validateDataFlowConsistency(nodes, edges);
    if (!dataFlowValidation.isValid) {
      errors.push(...dataFlowValidation.errors);
    }
    warnings.push(...dataFlowValidation.warnings);
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      summary: {
        totalNodes: nodes.length,
        validNodes: nodeValidations.filter(n => n.validation.isValid).length,
        totalEdges: edges.length,
        structureValid: structureValidation.isValid,
        dataFlowValid: dataFlowValidation.isValid
      },
      nodeValidations,
      structureValidation,
      dataFlowValidation
    };
  },

  /**
   * Validate individual node integrity within workflow context
   * @param {Object} node - Node to validate
   * @param {Array} allNodes - All workflow nodes
   * @param {Array} allEdges - All workflow edges
   * @returns {Object} Validation result
   */
  validateNodeIntegrity(node, allNodes, allEdges) {
    const errors = [];
    const warnings = [];
    
    if (!node?.data) {
      return ValidationResult.error(['Node data is required']);
    }
    
    // Basic node data validation
    const basicValidation = validateNodeData(node.data);
    if (!basicValidation.success) {
      errors.push(...basicValidation.errors.map(err => ({
        code: err.code,
        message: err.message,
        path: err.path,
        context: { section: err.section, nodeType: node.type }
      })));
    }
    
    // Validate connections exist
    const nodeEdges = allEdges.filter(edge =>
      edge.source === node.id || edge.target === node.id
    );
    
    // Check input connections against node data
    const inputEdges = nodeEdges.filter(edge => edge.target === node.id);
    const nodeConnections = Object.keys(node.data.input?.connections || {});
    
    // Warn if connections in edges don't match node data connections
    if (inputEdges.length !== nodeConnections.length) {
      warnings.push({
        code: 'CONNECTION_MISMATCH',
        message: `Node has ${nodeConnections.length} connections in data but ${inputEdges.length} in edges`,
        context: {
          dataConnections: nodeConnections.length,
          edgeConnections: inputEdges.length
        }
      });
    }
    
    // Validate node type specific requirements
    const typeValidation = this.validateNodeTypeRequirements(node, allNodes);
    if (!typeValidation.isValid) {
      errors.push(...typeValidation.errors);
    }
    warnings.push(...typeValidation.warnings);
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      connectionAnalysis: {
        inputEdges: inputEdges.length,
        outputEdges: nodeEdges.filter(edge => edge.source === node.id).length,
        dataConnections: nodeConnections.length
      }
    };
  },

  /**
   * Validate node type specific requirements
   * @param {Object} node - Node to validate
   * @param {Array} allNodes - All workflow nodes for context
   * @returns {Object} Validation result
   */
  validateNodeTypeRequirements(node, allNodes) {
    const errors = [];
    const warnings = [];
    const category = node.data?.meta?.category;
    
    if (!category) {
      errors.push({
        code: 'MISSING_NODE_CATEGORY',
        message: 'Node category is required for type validation',
        path: 'meta.category'
      });
      return { isValid: false, errors, warnings };
    }
    
    const typeRules = NodeTypeValidationRules[category];
    if (!typeRules) {
      warnings.push({
        code: 'UNKNOWN_NODE_CATEGORY',
        message: `Unknown node category '${category}' - specific validation skipped`,
        context: { category }
      });
      return { isValid: true, errors, warnings };
    }
    
    // Validate category-specific requirements
    switch (category) {
      case 'input':
        return this.validateInputNodeRequirements(node, typeRules);
      case 'process':
        return this.validateProcessNodeRequirements(node, typeRules);
      case 'output':
        return this.validateOutputNodeRequirements(node, typeRules);
      default:
        return { isValid: true, errors, warnings };
    }
  },

  /**
   * Validate input node specific requirements
   * @param {Object} node - Input node
   * @param {Object} rules - Validation rules
   * @returns {Object} Validation result
   */
  validateInputNodeRequirements(node, rules) {
    const errors = [];
    const warnings = [];
    const capabilities = node.data?.meta?.capabilities || [];
    
    // Check required capabilities
    const requiredCapabilities = rules.meta.constraints.capabilities.mustInclude;
    const missingCapabilities = requiredCapabilities.filter(cap => !capabilities.includes(cap));
    
    if (missingCapabilities.length > 0) {
      errors.push({
        code: 'MISSING_REQUIRED_CAPABILITIES',
        message: `Input node missing required capabilities: ${missingCapabilities.join(', ')}`,
        path: 'meta.capabilities',
        context: {
          missing: missingCapabilities,
          required: requiredCapabilities,
          current: capabilities
        }
      });
    }
    
    // Check for form fields if capability includes form-collection
    if (capabilities.includes('form-collection')) {
      const formFields = node.data?.input?.config?.formFields;
      if (!formFields || !Array.isArray(formFields) || formFields.length === 0) {
        errors.push({
          code: 'MISSING_FORM_FIELDS',
          message: 'Input node with form-collection capability must have formFields',
          path: 'input.config.formFields'
        });
      }
    }
    
    return { isValid: errors.length === 0, errors, warnings };
  },

  /**
   * Validate process node specific requirements
   * @param {Object} node - Process node
   * @param {Object} rules - Validation rules
   * @returns {Object} Validation result
   */
  validateProcessNodeRequirements(node, rules) {
    const errors = [];
    const warnings = [];
    
    // Process nodes must have a plugin
    if (!node.data?.plugin) {
      errors.push({
        code: 'PROCESS_NODE_REQUIRES_PLUGIN',
        message: 'Process nodes must have a plugin configuration',
        path: 'plugin'
      });
    }
    
    // Check required capabilities
    const capabilities = node.data?.meta?.capabilities || [];
    const requiredCapabilities = rules.meta.constraints.capabilities.mustInclude;
    const missingCapabilities = requiredCapabilities.filter(cap => !capabilities.includes(cap));
    
    if (missingCapabilities.length > 0) {
      errors.push({
        code: 'MISSING_REQUIRED_CAPABILITIES',
        message: `Process node missing required capabilities: ${missingCapabilities.join(', ')}`,
        path: 'meta.capabilities',
        context: {
          missing: missingCapabilities,
          required: requiredCapabilities,
          current: capabilities
        }
      });
    }
    
    return { isValid: errors.length === 0, errors, warnings };
  },

  /**
   * Validate output node specific requirements
   * @param {Object} node - Output node
   * @param {Object} rules - Validation rules
   * @returns {Object} Validation result
   */
  validateOutputNodeRequirements(node, rules) {
    const errors = [];
    const warnings = [];
    
    // Output nodes should not have output connections
    const outputDirectives = node.data?.output?.directives;
    if (outputDirectives && Object.keys(outputDirectives).length > 0) {
      warnings.push({
        code: 'OUTPUT_NODE_HAS_DIRECTIVES',
        message: 'Output nodes typically should not generate directives',
        path: 'output.directives',
        context: { directiveCount: Object.keys(outputDirectives).length }
      });
    }
    
    // Check required capabilities
    const capabilities = node.data?.meta?.capabilities || [];
    const requiredCapabilities = rules.meta.constraints.capabilities.mustInclude;
    const missingCapabilities = requiredCapabilities.filter(cap => !capabilities.includes(cap));
    
    if (missingCapabilities.length > 0) {
      errors.push({
        code: 'MISSING_REQUIRED_CAPABILITIES',
        message: `Output node missing required capabilities: ${missingCapabilities.join(', ')}`,
        path: 'meta.capabilities',
        context: {
          missing: missingCapabilities,
          required: requiredCapabilities,
          current: capabilities
        }
      });
    }
    
    return { isValid: errors.length === 0, errors, warnings };
  },

  /**
   * Validate workflow structure
   * @param {Array} nodes - Workflow nodes
   * @param {Array} edges - Workflow edges
   * @returns {Object} Validation result
   */
  validateWorkflowStructure(nodes, edges) {
    const errors = [];
    const warnings = [];
    
    // Check minimum requirements
    if (nodes.length === 0) {
      errors.push({
        code: 'EMPTY_WORKFLOW',
        message: 'Workflow must contain at least one node'
      });
      return { isValid: false, errors, warnings };
    }
    
    // Check for input nodes
    const inputNodes = nodes.filter(n => n.data?.meta?.category === 'input');
    if (inputNodes.length === 0) {
      warnings.push({
        code: 'NO_INPUT_NODES',
        message: 'Workflow has no input nodes - data entry may be limited'
      });
    }
    
    // Check for output nodes
    const outputNodes = nodes.filter(n => n.data?.meta?.category === 'output');
    if (outputNodes.length === 0) {
      warnings.push({
        code: 'NO_OUTPUT_NODES',
        message: 'Workflow has no output nodes - results may not be displayed'
      });
    }
    
    // Check for circular dependencies
    const circularDeps = this.detectCircularDependencies(nodes, edges);
    if (circularDeps.length > 0) {
      errors.push({
        code: 'CIRCULAR_DEPENDENCIES',
        message: `Circular dependencies detected: ${circularDeps.join(' -> ')}`,
        context: { cycles: circularDeps }
      });
    }
    
    // Check for orphaned nodes
    const orphanedNodes = this.findOrphanedNodes(nodes, edges);
    if (orphanedNodes.length > 0) {
      warnings.push({
        code: 'ORPHANED_NODES',
        message: `Found ${orphanedNodes.length} disconnected nodes`,
        context: { orphanedNodes }
      });
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      metrics: {
        inputNodes: inputNodes.length,
        processNodes: nodes.filter(n => n.data?.meta?.category === 'process').length,
        outputNodes: outputNodes.length,
        totalConnections: edges.length,
        orphanedNodes: orphanedNodes.length
      }
    };
  },

  /**
   * Validate data flow consistency across workflow
   * @param {Array} nodes - Workflow nodes
   * @param {Array} edges - Workflow edges
   * @returns {Object} Validation result
   */
  validateDataFlowConsistency(nodes, edges) {
    const errors = [];
    const warnings = [];
    const nodeMap = new Map();
    
    nodes.forEach(node => nodeMap.set(node.id, node));
    
    // Validate each edge for data flow consistency
    for (const edge of edges) {
      const sourceNode = nodeMap.get(edge.source);
      const targetNode = nodeMap.get(edge.target);
      
      if (!sourceNode || !targetNode) {
        errors.push({
          code: 'INVALID_EDGE_NODES',
          message: `Edge references non-existent nodes: ${edge.source} -> ${edge.target}`,
          context: { edgeId: edge.id, source: edge.source, target: edge.target }
        });
        continue;
      }
      
      // Check data type compatibility
      const sourceOutputType = this.inferNodeOutputType(sourceNode);
      const targetInputType = this.inferNodeInputType(targetNode, edge.targetHandle);
      
      if (sourceOutputType && targetInputType) {
        const compatibility = MultiConnectionValidator.validateDataTypeCompatibility(
          sourceOutputType,
          targetInputType
        );
        
        if (!compatibility.isValid) {
          warnings.push({
            code: 'DATA_TYPE_INCOMPATIBILITY',
            message: `Potential data type mismatch between ${edge.source} and ${edge.target}`,
            context: {
              sourceType: sourceOutputType,
              targetType: targetInputType,
              edgeId: edge.id
            }
          });
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      flowAnalysis: {
        totalFlows: edges.length,
        typeIncompatibilities: warnings.filter(w => w.code === 'DATA_TYPE_INCOMPATIBILITY').length
      }
    };
  },

  /**
   * Helper method to detect circular dependencies
   * @param {Array} nodes - Workflow nodes
   * @param {Array} edges - Workflow edges
   * @returns {Array} Array of circular dependency paths
   */
  detectCircularDependencies(nodes, edges) {
    const graph = new Map();
    const visited = new Set();
    const recursionStack = new Set();
    const cycles = [];
    
    // Build adjacency list
    nodes.forEach(node => graph.set(node.id, []));
    edges.forEach(edge => {
      if (graph.has(edge.source)) {
        graph.get(edge.source).push(edge.target);
      }
    });
    
    // DFS to detect cycles
    const dfs = (nodeId, path = []) => {
      if (recursionStack.has(nodeId)) {
        const cycleStart = path.indexOf(nodeId);
        if (cycleStart !== -1) {
          cycles.push([...path.slice(cycleStart), nodeId]);
        }
        return;
      }
      
      if (visited.has(nodeId)) return;
      
      visited.add(nodeId);
      recursionStack.add(nodeId);
      path.push(nodeId);
      
      const neighbors = graph.get(nodeId) || [];
      for (const neighbor of neighbors) {
        dfs(neighbor, [...path]);
      }
      
      recursionStack.delete(nodeId);
    };
    
    for (const nodeId of graph.keys()) {
      if (!visited.has(nodeId)) {
        dfs(nodeId);
      }
    }
    
    return cycles.flat();
  },

  /**
   * Helper method to find orphaned nodes
   * @param {Array} nodes - Workflow nodes
   * @param {Array} edges - Workflow edges
   * @returns {Array} Array of orphaned node IDs
   */
  findOrphanedNodes(nodes, edges) {
    if (edges.length === 0) {
      return nodes.map(n => n.id);
    }
    
    const connectedNodeIds = new Set();
    edges.forEach(edge => {
      connectedNodeIds.add(edge.source);
      connectedNodeIds.add(edge.target);
    });
    
    return nodes
      .filter(n => !connectedNodeIds.has(n.id))
      .map(n => n.id);
  },

  /**
   * Infer output data type from node
   * @param {Object} node - Source node
   * @returns {string|null} Inferred output type
   */
  inferNodeOutputType(node) {
    const category = node.data?.meta?.category;
    const capabilities = node.data?.meta?.capabilities || [];
    
    // Basic type inference based on category and capabilities
    if (category === 'input') {
      if (capabilities.includes('form-collection')) return 'object';
      if (capabilities.includes('file-upload')) return 'file';
      return 'any';
    }
    
    if (category === 'process') {
      if (capabilities.includes('llm-processing')) return 'string';
      if (capabilities.includes('transformation')) return 'any';
      return 'object';
    }
    
    if (category === 'output') {
      return 'any'; // Output nodes typically just pass through data
    }
    
    return null;
  },

  /**
   * Infer expected input data type for node
   * @param {Object} node - Target node
   * @param {string} handle - Target handle
   * @returns {string|null} Expected input type
   */
  inferNodeInputType(node, handle = 'default') {
    const handleConfig = node.data?.styling?.handles?.input || [];
    const handleDef = handleConfig.find(h => h.id === handle);
    
    if (handleDef?.behavior?.acceptedDataTypes) {
      return handleDef.behavior.acceptedDataTypes[0]; // Return first accepted type
    }
    
    // Default inference based on category
    const category = node.data?.meta?.category;
    if (category === 'process') return 'any';
    if (category === 'output') return 'any';
    
    return null;
  }
};

// ===========================
// COMPREHENSIVE VALIDATION SYSTEM
// ===========================

/**
 * Main enhanced validation system that orchestrates all validators
 */
export class ComprehensiveValidationSystem {
  constructor() {
    this.validators = {
      schema: SchemaValidationRules,
      multiConnection: MultiConnectionValidator,
      directive: DirectiveValidator,
      crossNode: CrossNodeValidator
    };
  }

  /**
   * Validate complete node data with all validation layers
   * @param {Object} nodeData - Node data to validate
   * @param {Object} context - Validation context
   * @returns {Object} Comprehensive validation result
   */
  validateNodeData(nodeData, context = {}) {
    const results = {
      basic: validateNodeData(nodeData),
      schema: this.validateAgainstSchema(nodeData),
      multiConnection: null,
      directives: null
    };

    // Multi-connection validation if applicable
    if (nodeData?.input?.connections && Object.keys(nodeData.input.connections).length > 1) {
      results.multiConnection = MultiConnectionValidator.validateMultiConnectionSetup(nodeData);
    }

    // Directive validation if applicable
    if (nodeData?.output?.directives) {
      results.directives = this.validateNodeDirectives(nodeData.output.directives);
    }

    // Combine all results
    const allErrors = [];
    const allWarnings = [];
    let isValid = true;

    Object.entries(results).forEach(([key, result]) => {
      if (result) {
        if (result.success === false || result.isValid === false) {
          isValid = false;
        }
        
        if (result.errors) {
          allErrors.push(...result.errors.map(err => ({
            ...err,
            source: key
          })));
        }
        
        if (result.warnings) {
          allWarnings.push(...result.warnings.map(warn => ({
            ...warn,
            source: key
          })));
        }
      }
    });

    return {
      isValid,
      errors: allErrors,
      warnings: allWarnings,
      results,
      summary: {
        validationLayers: Object.keys(results).filter(k => results[k]).length,
        hasMultipleConnections: !!results.multiConnection,
        hasDirectives: !!results.directives,
        criticalErrors: allErrors.filter(e => e.severity === 'critical').length
      }
    };
  }

  /**
   * Validate against enhanced schema rules
   * @param {Object} nodeData - Node data to validate
   * @returns {Object} Schema validation result
   */
  validateAgainstSchema(nodeData) {
    const errors = [];
    const warnings = [];
    
    if (!nodeData) {
      return ValidationResult.error(['NodeData is required']);
    }

    const category = nodeData.meta?.category;
    if (category && NodeTypeValidationRules[category]) {
      const typeRules = NodeTypeValidationRules[category];
      
      // Validate category-specific constraints
      const typeValidation = this.validateNodeTypeConstraints(nodeData, typeRules);
      if (!typeValidation.isValid) {
        errors.push(...typeValidation.errors);
      }
      warnings.push(...typeValidation.warnings);
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      schemaCompliance: {
        category,
        hasTypeSpecificRules: !!(category && NodeTypeValidationRules[category])
      }
    };
  }

  /**
   * Validate node type specific constraints
   * @param {Object} nodeData - Node data
   * @param {Object} typeRules - Type-specific rules
   * @returns {Object} Validation result
   */
  validateNodeTypeConstraints(nodeData, typeRules) {
    const errors = [];
    const warnings = [];

    // Validate meta constraints
    if (typeRules.meta?.constraints) {
      const metaValidation = this.validateMetaConstraints(nodeData.meta, typeRules.meta.constraints);
      if (!metaValidation.isValid) {
        errors.push(...metaValidation.errors);
      }
      warnings.push(...metaValidation.warnings);
    }

    // Validate other sections as needed
    // This would be expanded based on specific type requirements

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Validate meta section constraints
   * @param {Object} meta - Meta data
   * @param {Object} constraints - Constraints to validate
   * @returns {Object} Validation result
   */
  validateMetaConstraints(meta, constraints) {
    const errors = [];
    const warnings = [];
    
    if (!meta) {
      return ValidationResult.error(['Meta section is required']);
    }

    // Validate capabilities constraints
    if (constraints.capabilities) {
      const capabilities = meta.capabilities || [];
      
      // Check required capabilities
      if (constraints.capabilities.mustInclude) {
        const missing = constraints.capabilities.mustInclude.filter(cap =>
          !capabilities.includes(cap)
        );
        
        if (missing.length > 0) {
          errors.push({
            code: 'MISSING_REQUIRED_CAPABILITIES',
            message: `Missing required capabilities: ${missing.join(', ')}`,
            path: 'meta.capabilities',
            context: { missing, required: constraints.capabilities.mustInclude }
          });
        }
      }
      
      // Check valid capabilities
      if (constraints.capabilities.validCapabilities) {
        const invalid = capabilities.filter(cap =>
          !constraints.capabilities.validCapabilities.includes(cap)
        );
        
        if (invalid.length > 0) {
          warnings.push({
            code: 'INVALID_CAPABILITIES',
            message: `Invalid capabilities found: ${invalid.join(', ')}`,
            path: 'meta.capabilities',
            context: {
              invalid,
              valid: constraints.capabilities.validCapabilities
            }
          });
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Validate node directives
   * @param {Object} directives - Directives to validate
   * @returns {Object} Validation result
   */
  validateNodeDirectives(directives) {
    const errors = [];
    const warnings = [];
    const directiveResults = [];
    
    if (!directives || typeof directives !== 'object') {
      return {
        isValid: true,
        errors: [],
        warnings: [{
          code: 'NO_DIRECTIVES',
          message: 'Node has no directives to validate'
        }]
      };
    }

    // Validate each directive
    Object.entries(directives).forEach(([targetNodeId, nodeDirectives]) => {
      if (Array.isArray(nodeDirectives)) {
        nodeDirectives.forEach((directive, index) => {
          const result = DirectiveValidator.validateDirectiveStructure(directive);
          directiveResults.push({
            targetNodeId,
            directiveIndex: index,
            result
          });
          
          if (!result.isValid) {
            errors.push(...result.errors.map(err => ({
              ...err,
              context: {
                ...err.context,
                targetNodeId,
                directiveIndex: index
              }
            })));
          }
          warnings.push(...result.warnings);
        });
      }
    });

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      directiveAnalysis: {
        totalTargets: Object.keys(directives).length,
        totalDirectives: directiveResults.length,
        validDirectives: directiveResults.filter(d => d.result.isValid).length
      }
    };
  }

  /**
   * Validate complete workflow with all nodes and connections
   * @param {Array} nodes - Workflow nodes
   * @param {Array} edges - Workflow edges
   * @returns {Object} Comprehensive workflow validation
   */
  validateWorkflow(nodes, edges) {
    const workflowValidation = CrossNodeValidator.validateWorkflowIntegrity(nodes, edges);
    const nodeValidations = [];
    
    // Validate each node comprehensively
    for (const node of nodes) {
      const nodeValidation = this.validateNodeData(node.data, {
        workflowContext: { nodes, edges },
        nodeId: node.id
      });
      
      nodeValidations.push({
        nodeId: node.id,
        validation: nodeValidation
      });
    }
    
    // Aggregate results
    const allErrors = [...workflowValidation.errors];
    const allWarnings = [...workflowValidation.warnings];
    
    nodeValidations.forEach(nv => {
      allErrors.push(...nv.validation.errors.map(err => ({
        ...err,
        context: { ...err.context, nodeId: nv.nodeId }
      })));
      allWarnings.push(...nv.validation.warnings.map(warn => ({
        ...warn,
        context: { ...warn.context, nodeId: nv.nodeId }
      })));
    });
    
    return {
      isValid: allErrors.length === 0,
      errors: allErrors,
      warnings: allWarnings,
      summary: {
        totalNodes: nodes.length,
        totalEdges: edges.length,
        validNodes: nodeValidations.filter(nv => nv.validation.isValid).length,
        workflowStructureValid: workflowValidation.isValid,
        totalErrors: allErrors.length,
        totalWarnings: allWarnings.length
      },
      workflowValidation,
      nodeValidations
    };
  }
}

// Export main validation system instance
export const enhancedValidation = new ComprehensiveValidationSystem();